# -*- coding: utf-8 -*-
"""(study)complex_space_MNIST

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EYBK66OXNZWaLbruQlENb_OJeNTusUzw

# 모듈 불러오기
"""

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
from tqdm.notebook import tqdm
# %matplotlib inline
from scipy import fftpack, fft
import numpy as np
from PIL import Image
import math
import pandas as pd
from numba import jit, cuda 

PI = math.pi


# Commented out IPython magic to ensure Python compatibility.
# 텐서플로우 이하에서 사용
import tensorflow as tf
from tensorflow import keras

from tensorflow.keras import models, layers, backend
from tensorflow.keras.datasets import mnist

mnist = mnist.load_data()
X_train, y_train = mnist[0][0], mnist[0][1]
X_test, y_test = mnist[1][0], mnist[1][1]

def calculateCenter(img):
  # 무게중심 구하기

  height = img.shape[0]
  width = img.shape[1]

  R = list()
  for y in range(height):
    for x in range(width):
      if img[y,x]:            
        R.append([x, (height-y)*1j])

  # 질량의 합
  M = len(R)

  # 질량중심 벡터는 이미지를 기준으로 (x,y) => (height-y)
  R = np.array(R)
  R_x = R[:,0]
  R_y = R[:,1]

  R_x_sum = R_x.sum()
  R_y_sum = R_y.sum()

  center = np.round(R_x_sum/M).real , (np.round(R_y_sum/M)*-1j).real
 
  height_center = center[1]
  width_center = center[0]
  return width_center, height_center, M, R



# 사분면별 데이터 얻기
# @jit(target ="cuda" )    
def vectorsQuarterDivided(R):
  # 1,2,3,4 사분면을 나눠보자
  first   = np.array([])
  second  = np.array([])
  third   = np.array([])
  fourth  = np.array([])
  for i in R:
    x,y = i
    if x >= 0 and y >= 0:
      size1 = np.sqrt(x**2 + y**2)
      theta1 = np.arccos(x/size1)
      first = np.append(first, [x,y,size1,theta1], 0)
      # first.append([x,y,size1,theta1]) # [x,y,size1,theta1]
      # print('1사분면: ' , x,y)
    if x < 0 and y >= 0:
      size2 = np.sqrt(x**2 + y**2)
      theta2 = np.arccos(x/size2)
      second = np.append(second, [x,y,size2,theta2], 0)
      # second.append([x,y,size2, theta2])
      # print('2사분면: ', x,y)
    if x < 0 and y < 0:
      size3 = np.sqrt(x**2 + y**2)
      theta3 = np.arccos(x/size3) + PI
      third = np.append(third, [x,y,size3,theta3], 0)
      # third.append([x,y,size3, theta3])
      # print('3사분면: ', x,y)
    if x >= 0 and y < 0:
      size4 = np.sqrt(x**2 + y**2)
      theta4 = np.arccos(y/size4) + PI
      fourth = np.append(fourth, [x,y,size4,theta4], 0)
      # fourth.append([x,y,size4, theta4])
      # print('4사분면: ', x,y)
    all_vectors_ordered = np.array([first, second, third, fourth])
    
    # size가 0인 벡터가 존재 => 결측치 => theta값 0 으로 대체
    df_tmp = pd.DataFrame(all_vectors_ordered)
    df_tmp.fillna(0, inplace= True)
    all_vectors_ordered = df_tmp.to_numpy()

    quarter_number = [len(first), len(second), len(third), len(fourth)]
  return [all_vectors_ordered, quarter_number]

X_train.shape, X_test.shape

"""## 필요한 데이터 담기

- 무게중심
- 사분면별 픽셀개수
"""

import pickle
import time

# X_train, X_test 데이터에서 데이터 한개씩 뽑아서 무게중심과, 사분면별 개수 데이터
# X_train_dict = {
#   'quarter_number' :  list(),
#   'quarter_number_ratio' : list(),
#   'center_coord' : list()
# }

X_train_array = np.array([])

print("START~~~")
cnt = 0

start = time.time()
with open('X_train_array.data', 'wb') as f:

  for num in tqdm(range(X_train.shape[0])):
  # for num in tqdm(range(10000)):

    # 데이터 처리
    X_train[num].shape
    width_center, height_center, M, R = calculateCenter(X_train[num]) # 여기서 받은 R은 복소수를 포함하고 있다 => real inteager로 바꿔야 한다
    R[:,0] = R[:,0].real
    R[:,1] = R[:,1].imag
    R = R.real.astype(int)
    R_adjusted = R - np.array([width_center, height_center])

    # 데이터 담기
    tmp = vectorsQuarterDivided(R_adjusted)
    quarter_number = np.array(tmp[0])
    quarter_number_ratio = np.array(tmp[1])/M
    center_coord = np.array([width_center, height_center])

    X_train_array = np.append(X_train_array, [quarter_number, quarter_number_ratio, center_coord], 0)

    cnt += 1
    print(cnt)

  pickle.dump(X_train_array, f)
print('end time : ' + time.time() - start)


