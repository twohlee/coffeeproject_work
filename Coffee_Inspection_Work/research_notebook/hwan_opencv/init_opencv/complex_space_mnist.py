# -*- coding: utf-8 -*-
"""(study)complex_space_MNIST

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EYBK66OXNZWaLbruQlENb_OJeNTusUzw

# 모듈 불러오기
"""

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
import numpy as np
from tqdm.notebook import tqdm
# %matplotlib inline
from scipy import fftpack, fft
import numpy as np
from PIL import Image
import math
import pandas as pd

PI = math.pi

"""# 데이터 불러오기"""

img_data_countour = list()
img_data = list()
for num in range(0,10):
  
  # tmp_img_countour = Image.open(f'/content/drive/My Drive/Coffee_Inspection/참고자료/MINIST/output/{num}_contour.png의 사본')
  # tmp_img = Image.open(f'/content/drive/My Drive/Coffee_Inspection/참고자료/MINIST/output/{num}.png의 사본')

  tmp_img_countour = Image.open(f'./mnist_image/{num}_contour.png')
  tmp_img = Image.open(f'./mnist_image/{num}.png')
  
  tmp_img_countour = 255 - np.array(tmp_img_countour.convert('L'))
  tmp_img = 255 - np.array(tmp_img.convert('L'))
  
  img_data_countour.append(tmp_img_countour)
  img_data.append(tmp_img)

# 컨투어 내부 이미지 구현
fig = plt.figure(figsize = (10,10))

for num in range(1,11):
  ax = fig.add_subplot(2,5,num)
  ax.imshow(img_data[num-1])
  ax.set_title(str(num-1),fontsize = 15, color = 'w')

# 컨투어 이미지 확인
fig = plt.figure(figsize = (10,10))

for num in range(1,11):
  ax = fig.add_subplot(2,5,num)
  ax.imshow(img_data_countour[num-1])
  ax.set_title(str(num-1),fontsize = 15, color = 'w')

"""# 이미지 데이터 처리하기

## 무게중심 구하기
"""

def calculateCenter(img_num):
  # 무게중심 구하기
  img_num = img_num

  height = img_data[img_num].shape[0]
  width = img_data[img_num].shape[1]

  R = list()
  for y in range(height):
    for x in range(width):
      if img_data[img_num][y,x]:            
        R.append([x, (height-y)*1j])

  # 질량의 합
  M = len(R)

  # 질량중심 벡터는 이미지를 기준으로 (x,y) => (height-y)
  R = np.array(R)
  R_x = R[:,0]
  R_y = R[:,1]

  R_x_sum = R_x.sum()
  R_y_sum = R_y.sum()

  center = np.round(R_x_sum/M).real , (np.round(R_y_sum/M)*-1j).real
 
  height_center = center[1]
  width_center = center[0]
  return width_center, height_center, M, R

for i in range(9):
  print(str(i), ':', 'width_center = ', calculateCenter(i)[0], '     ' , 'height_center = ', calculateCenter(i)[1], '     ' , 'M = ', calculateCenter(i)[2])

"""## 벡터그리기"""

# 벡터 그리기
def drawVector(img_num):
  height = img_data_countour[img_num].shape[0]
  width = img_data_countour[img_num].shape[1]

  fig = plt.figure(figsize = (10,10))
  ax = fig.gca()
  ax.set_xlim([-width, 2*width])
  ax.set_ylim([-height,2*height])
  all_vectors = list()
  for y in range(img_data_countour[img_num].shape[0]):
    for x in range(img_data_countour[img_num].shape[1]):
      if img_data_countour[img_num][y,x]:        
        # 이미지 상에서 (x,y)로 나타내자
        all_vectors.append(    [ x-calculateCenter(img_num)[0], (height - y) - calculateCenter(img_num)[1] ])
        ax.quiver(calculateCenter(img_num)[0],calculateCenter(img_num)[1],x-calculateCenter(img_num)[0], (height - y) - calculateCenter(img_num)[1] , angles='xy', scale_units='xy',scale=1, width = 0.001)
        
  sum_vector1 = np.array([np.array(all_vectors)[:,0].sum(), np.array(all_vectors)[:,1].sum()]) # (x,y)
  ax.quiver(calculateCenter(img_num)[0],calculateCenter(img_num)[1],sum_vector1[0], sum_vector1[1] , angles='xy', scale_units='xy',scale=1, color = 'r')

drawVector(1)

"""## 푸리에 시리즈 구현해보기"""

# 윤곽데이터 얻기
def dimensionExpansion(img_num):
  height = img_data_countour[img_num].shape[0]
  width = img_data_countour[img_num].shape[1]

  all_vectors = list()
  for y in range(img_data_countour[img_num].shape[0]):
    for x in range(img_data_countour[img_num].shape[1]):
      if img_data_countour[img_num][y,x]:        
        # 이미지 상에서 (x,y)로 나타내자
        all_vectors.append(    [ x-calculateCenter(img_num)[0], (height - y) - calculateCenter(img_num)[1] ])
  return np.array(all_vectors)

fig = plt.figure(figsize = (30,10))
for num in range(1,11):
  all_vectors = dimensionExpansion(num-1)
  all_vectors_size = np.sqrt(all_vectors[:,0]**2 + all_vectors[:,1]**2)
  all_vectors_angle = np.arcsin(all_vectors[:,1]/all_vectors_size) # 라디안 값으로 주어진다

  # 이미지 확인
  ax1 = fig.add_subplot(4,5,num)
  ax2 = fig.add_subplot(4,5,num+10)
  ax1.plot(all_vectors_size, color = 'r')
  ax2.plot(all_vectors_angle, color = 'b')
  ax1.set_title(str(num-1),fontsize = 15, color = 'w')
  ax2.set_title(str(num-1),fontsize = 15, color = 'w')

# 위의 그래프로는 무엇인지 해석하기가 너무 어렵다. => feature map을 잡아내기가 어렵다.

# 사분면별 데이터 얻기
def vectorsQuarterDivided(img_num):
  # 1,2,3,4 사분면을 나눠보자
  first   = list()
  second  = list()
  third   = list()
  fourth  = list()
  first_dict    = dict()
  second_dict   = dict()
  third_dict    = dict()
  fourth_dict   = dict()
  for i in dimensionExpansion(img_num):
    x,y = i
    if x >= 0 and y >= 0:
      size1 = np.sqrt(x**2 + y**2)
      theta1 = np.arccos(x/size1)
      first.append([x,y,size1,theta1]) # [x,y,size1,theta1]
      # print('1사분면: ' , x,y)
    if x < 0 and y >= 0:
      size2 = np.sqrt(x**2 + y**2)
      theta2 = np.arccos(x/size2)
      second.append([x,y,size2, theta2])
      # print('2사분면: ', x,y)
    if x < 0 and y < 0:
      size3 = np.sqrt(x**2 + y**2)
      theta3 = np.arccos(x/size3) + PI
      third.append([x,y,size3, theta3])
      # print('3사분면: ', x,y)
    if x >= 0 and y < 0:
      size4 = np.sqrt(x**2 + y**2)
      theta4 = np.arccos(y/size4) + PI
      fourth.append([x,y,size4, theta4])
      # print('4사분면: ', x,y)
    all_vectors_ordered = np.array(first + second + third + fourth)
    
    # size가 0인 벡터가 존재 => 결측치 => theta값 0 으로 대체
    df_tmp = pd.DataFrame(all_vectors_ordered)
    df_tmp.fillna(0, inplace= True)
    all_vectors_ordered = df_tmp.to_numpy()

    quarter_number = [len(first), len(second), len(third), len(fourth)]
  return { 'all_vectors_ordered' : all_vectors_ordered, 'quarter_number' : quarter_number }



fig = plt.figure(figsize = (30,10))
for num in range(1,11):
  all_vectors_ordered = vectorsQuarterDivided(num-1)['all_vectors_ordered']

  # 이미지 확인
  ax1 = fig.add_subplot(4,5,num)
  ax2 = fig.add_subplot(4,5,num+10)
  ax1.plot(all_vectors_ordered[:,2], color = 'r')
  ax2.plot(all_vectors_ordered[:,3], color = 'b')
  ax1.set_title(str(num-1),fontsize = 15, color = 'w')
  ax2.set_title(str(num-1),fontsize = 15, color = 'w')
  
  for i in range(4):
    ax1.axvline(x = np.sum(vectorsQuarterDivided(num-1)['quarter_number'][0:i+1]), color='g', linestyle='--', linewidth=3)
    ax2.axvline(x = np.sum(vectorsQuarterDivided(num-1)['quarter_number'][0:i+1]), color='g', linestyle='--', linewidth=3)

"""## 중간 점검

- 현재 이미지를 한 차원 증가시켜서 이미지 갯수를 이미지의 윤곽선 픽셀 개수만큼 획득
- 1,2,3,4 사분면을 나눠서 각각 데이터를 확인
- 1,2,3,4 사분면 순서대로 그래프는 그릴 수 있었지만, 각 사분면안에서 픽셀을 연속적으로 그릴 수 없는 상태
- 윤곽선을 특정 기준에 따라서 연속적으로 트래킹 할 수 있는 방법을 모색해야 한다

# MINIST 숫자를 사분면별 픽셀 비율 확인
"""

# Commented out IPython magic to ensure Python compatibility.
# 텐서플로우 이하에서 사용
import tensorflow as tf
from tensorflow import keras
# %tensorflow_version 1.x

from tensorflow.keras import models, layers, backend
from tensorflow.keras.datasets import mnist

mnist = mnist.load_data()
X_train, y_train = mnist[0][0], mnist[0][1]
X_test, y_test = mnist[1][0], mnist[1][1]

def calculateCenter(img):
  # 무게중심 구하기

  height = img.shape[0]
  width = img.shape[1]

  R = list()
  for y in range(height):
    for x in range(width):
      if img[y,x]:            
        R.append([x, (height-y)*1j])

  # 질량의 합
  M = len(R)

  # 질량중심 벡터는 이미지를 기준으로 (x,y) => (height-y)
  R = np.array(R)
  R_x = R[:,0]
  R_y = R[:,1]

  R_x_sum = R_x.sum()
  R_y_sum = R_y.sum()

  center = np.round(R_x_sum/M).real , (np.round(R_y_sum/M)*-1j).real
 
  height_center = center[1]
  width_center = center[0]
  return width_center, height_center, M, R

# 사분면별 데이터 얻기
def vectorsQuarterDivided(R):
  # 1,2,3,4 사분면을 나눠보자
  first   = list()
  second  = list()
  third   = list()
  fourth  = list()
  first_dict    = dict()
  second_dict   = dict()
  third_dict    = dict()
  fourth_dict   = dict()
  for i in R:
    x,y = i
    if x >= 0 and y >= 0:
      size1 = np.sqrt(x**2 + y**2)
      theta1 = np.arccos(x/size1)
      first.append([x,y,size1,theta1]) # [x,y,size1,theta1]
      # print('1사분면: ' , x,y)
    if x < 0 and y >= 0:
      size2 = np.sqrt(x**2 + y**2)
      theta2 = np.arccos(x/size2)
      second.append([x,y,size2, theta2])
      # print('2사분면: ', x,y)
    if x < 0 and y < 0:
      size3 = np.sqrt(x**2 + y**2)
      theta3 = np.arccos(x/size3) + PI
      third.append([x,y,size3, theta3])
      # print('3사분면: ', x,y)
    if x >= 0 and y < 0:
      size4 = np.sqrt(x**2 + y**2)
      theta4 = np.arccos(y/size4) + PI
      fourth.append([x,y,size4, theta4])
      # print('4사분면: ', x,y)
    all_vectors_ordered = np.array(first + second + third + fourth)
    
    # size가 0인 벡터가 존재 => 결측치 => theta값 0 으로 대체
    df_tmp = pd.DataFrame(all_vectors_ordered)
    df_tmp.fillna(0, inplace= True)
    all_vectors_ordered = df_tmp.to_numpy()

    quarter_number = [len(first), len(second), len(third), len(fourth)]
  return { 'all_vectors_ordered' : all_vectors_ordered, 'quarter_number' : quarter_number }

X_train.shape, X_test.shape

"""## 필요한 데이터 담기

- 무게중심
- 사분면별 픽셀개수
"""

import pickle
import time

# X_train, X_test 데이터에서 데이터 한개씩 뽑아서 무게중심과, 사분면별 개수 데이터
X_train_dict = {
  'quarter_number' :  list(),
  'quarter_number_ratio' : list(),
  'center_coord' : list()
}


print("START~~~")
cnt = 0

start = time.time()
with open('X_train.data', 'wb') as f:

  # for num in tqdm(range(X_train.shape[0])):
  for num in tqdm(range(10000)):

    # 데이터 처리
    X_train[num].shape
    width_center, height_center, M, R = calculateCenter(X_train[num]) # 여기서 받은 R은 복소수를 포함하고 있다 => real inteager로 바꿔야 한다
    R[:,0] = R[:,0].real
    R[:,1] = R[:,1].imag
    R = R.real.astype(int)
    R_adjusted = R - np.array([width_center, height_center])

    # 데이터 담기
    X_train_dict['quarter_number'].append(np.array(vectorsQuarterDivided(R_adjusted)['quarter_number']))
    X_train_dict['quarter_number_ratio'].append(np.array(vectorsQuarterDivided(R_adjusted)['quarter_number'])/M)
    X_train_dict['center_coord'].append([width_center, height_center])
    cnt += 1
    print(cnt)

  pickle.dump(X_train_dict, f)
print('end time : ' + time.time() - start)


